{"version":3,"sources":["webpack://draw/webpack/universalModuleDefinition","webpack://draw/webpack/bootstrap","webpack://draw/./src/canvas.ts","webpack://draw/./src/index.ts","webpack://draw/./src/input.ts","webpack://draw/./src/num.ts","webpack://draw/./src/vector.ts"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjF+B;AACE;AAE1B,MAAM,IAAK,SAAQ,4CAAK;IAkB3B,YAAY,MAAe;QACvB,KAAK,EAAE;QAjBX,0BAA2B;QAC3B,uBAA+B;QAWxB,UAAK,GAAG,CAAC;QAEhB,4BAAoB,CAAC;QAKjB,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC;QAE9B,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC;QAE3B,IAAI,CAAC,cAAc,uCAAc;IACrC,CAAC;IAlBD,IAAI,KAAK,KAAK,OAAO,sCAAa,KAAK,EAAC,CAAC;IACzC,IAAI,KAAK,CAAC,CAAS,IAAI,sCAAa,KAAK,GAAG,CAAC,EAAC,CAAC;IAE/C,IAAI,MAAM,KAAK,OAAO,sCAAa,MAAM,EAAC,CAAC;IAC3C,IAAI,MAAM,CAAC,CAAS,IAAI,sCAAa,MAAM,GAAG,CAAC,EAAC,CAAC;IAgBzC,iBAAiB,CAAC,MAAe;QACrC,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,EAAE;QACjC,IAAI,QAAQ,EAAE;YACV,MAAM,MAAM,GAAG,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAsB;YACrE,IAAI,MAAM,KAAK,IAAI;gBAAE,2BAAI,WAAW,MAAM;;gBACrC,2BAAI,WAAW,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAsB;SACzE;aACI;YACD,2BAAI,WAAW,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAsB;YACjE,QAAQ,CAAC,IAAI,CAAC,WAAW,uCAAc;SAC1C;QACD,2BAAI,QAAQ,sCAAa,UAAU,CAAC,IAAI,CAA6B;IACzE,CAAC;IAEO,cAAc,CAAC,MAAe;QAClC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,MAAM,IAAI,EAAE;QACtC,IAAI,CAAC,KAAK,GAAG,KAAK,IAAI,IAAI;QAC1B,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,IAAI;IAChC,CAAC;IAMS,cAAc,CAAC,IAAI,GAAG,KAAK;QACjC,MAAM,CAAC,GAAG,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC;QACtC,OAAO,CAAC;IACZ,CAAC;IAEM,OAAO,CAAC,EAAc;QACzB,EAAE,EAAE;IACR,CAAC;IAMM,KAAK,CAAC,EAA2C;QACpD,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACnB,IAAI,CAAC,WAAW,GAAG,EAAE;SACxB;QAED,IAAI,kDAAyB,CAAC;YAAE,OAAM;QAEtC,IAAI,EAAE;YAAE,EAAE,oCAAW;IACzB,CAAC;IAMM,IAAI,CAAC,EAA2C;QACnD,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB,IAAI,CAAC,UAAU,GAAG,EAAE;SACvB;QAED,IAAI,kDAAyB,CAAC;YAAE,OAAM;QAEtC,IAAI,QAAQ,CAAC,MAAM,KAAK,IAAI,EAAE;YAC1B,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;YAC/C,OAAM;SACT;QACD,IAAI,CAAC,KAAK,EAAE;QACZ,MAAM,QAAQ,GAAG,IAAI,8CAAM,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC;QACrD,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC;QAClC,IAAI,EAAE;YAAE,EAAE,oCAAW;;YAChB,MAAM,KAAK,CAAC,kBAAkB,CAAC;QACpC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;IACnD,CAAC;IAMM,YAAY,CAAC,KAAa;QAC7B,mCAAU,SAAS,GAAG,KAAK;IAC/B,CAAC;IAKO,MAAM;QACV,mCAAU,MAAM,EAAE;IACtB,CAAC;IAEO,SAAS;QACb,mCAAU,SAAS,EAAE;IACzB,CAAC;IAEO,SAAS;QACb,mCAAU,SAAS,EAAE;IACzB,CAAC;IASM,IAAI,CAAC,EAAU,EAAE,EAAU,EAAE,EAAU,EAAE,EAAU;QACtD,IAAI,CAAC,SAAS,EAAE;QAChB,mCAAU,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC;QACxB,mCAAU,MAAM,CAAC,EAAE,EAAE,EAAE,CAAC;QACxB,IAAI,CAAC,SAAS,EAAE;QAChB,IAAI,CAAC,MAAM,EAAE;IACjB,CAAC;IAEM,KAAK;QACR,mCAAU,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC;IACtD,CAAC;IAED,KAAK,CAAC,SAAS,CAAC,IAAY;QACxB,sGAAyB;QACzB,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAClC,sGAAyB;QACzB,IAAI,oDAA2B,CAAC,EAAE;YAC9B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC;YAC5B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;SAC7B;IACL,CAAC;IAED,SAAS,CAAC,IAAY;QAClB,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;IAC/B,CAAC;IAED,KAAK,CAAC,IAAY;QACd,OAAO,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;YACnB,UAAU,CAAC,GAAG,EAAE;gBACZ,CAAC,EAAE;YACP,CAAC,EAAE,IAAI,CAAC,CAAC;QACb,CAAC,CAAC;IACN,CAAC;CACJ;;;;;;;;;;;;;;ACrKD;AAAA;AAAA;AAAA;AAA+B;AACE;AACA;AAEjC,MAAM,CAAC,IAAI,GAAG,4CAAI;AAElB,MAAM,CAAC,GAAG,GAAG,wCAAG;AAEhB,MAAM,CAAC,IAAI,GAAG,yCAAI;AAElB,MAAM,CAAC,MAAM,GAAG,8CAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVW;AAE1B,MAAM,KAAK;IAAlB;QAEI,0BAA2B;QAC3B,oBAAY,IAAI,8CAAM,EAAE;QAExB,6BAAqB,EAAE;QAChB,UAAK,GAAG,CAAC;QACT,cAAS,GAAG,CAAC;QAqCb,oBAAe,GAAa,EAAE;QAE9B,cAAS,GAAG,KAAK;IAgG5B,CAAC;IArIG,IAAI,MAAM;QACN,OAAO,wCAAe,CAAC;IAC3B,CAAC;IACD,IAAI,MAAM,CAAC,CAAS;QAChB,wCAAe,CAAC,GAAG,CAAC;IACxB,CAAC;IACD,IAAI,MAAM;QACN,OAAO,wCAAe,CAAC;IAC3B,CAAC;IACD,IAAI,MAAM,CAAC,CAAS;QAChB,wCAAe,CAAC,GAAG,CAAC;IACxB,CAAC;IAED,IAAI,OAAO;QACP,MAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM;QACvC,IAAI,GAAG,GAAG,CAAC,EAAE;YACT,OAAO,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;SACnC;aACI,IAAI,GAAG,KAAK,CAAC,EAAE;YAChB,OAAO,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;SACnC;QACD,OAAO,IAAI,CAAC,MAAM;IACtB,CAAC;IAED,IAAI,OAAO;QACP,MAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM;QACvC,IAAI,GAAG,GAAG,CAAC,EAAE;YACT,OAAO,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;SACnC;aACI,IAAI,GAAG,KAAK,CAAC,EAAE;YAChB,OAAO,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;SACnC;QACD,OAAO,IAAI,CAAC,MAAM;IACtB,CAAC;IAMD,IAAI,SAAS;QACT,MAAM,GAAG,GAAG,sCAAa,qBAAqB,EAAE;QAChD,OAAO;YACH,IAAI,EAAE,GAAG,CAAC,IAAI;YACd,GAAG,EAAE,GAAG,CAAC,GAAG;YACZ,KAAK,EAAE,GAAG,CAAC,KAAK;YAChB,MAAM,EAAE,GAAG,CAAC,MAAM;SACrB;IACL,CAAC;IAEM,oBAAoB,CAAC,KAAa;QACrC,2BAAI,sBAAsB,KAAK;IACnC,CAAC;IAES,mBAAmB,CAAC,eAAuB;QACjD,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,eAAe,CAAC;QAC7C,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,mDAA0B,EAAE;YACvD,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE;SAC7B;IACL,CAAC;IAES,cAAc,CAAC,MAAyB;QAE9C,2BAAI,WAAW,MAAM;QAErB,IAAI,CAAC,eAAe,EAAE;QACtB,IAAI,CAAC,eAAe,EAAE;QACtB,IAAI,CAAC,aAAa,EAAE;IACxB,CAAC;IAKO,eAAe;QACnB,sCAAa,gBAAgB,CACzB,WAAW,EACX,CAAC,EAAc,EAAE,EAAE;YACf,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS;YAChC,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,CAAC;YACtB,IAAI,EAAE,CAAC,KAAK,EAAE;gBACV,IAAI,GAAG,EAAE,CAAC,KAAK;gBACf,IAAI,GAAG,EAAE,CAAC,KAAK;aAClB;iBAAM,IAAI,EAAE,CAAC,OAAO,EAAE;gBACnB,IAAI,GAAG,EAAE,CAAC,OAAO,GAAG,QAAQ,CAAC,eAAe,CAAC,UAAU,GAAG,QAAQ,CAAC,IAAI,CAAC,UAAU;gBAClF,IAAI,GAAG,EAAE,CAAC,OAAO,GAAG,QAAQ,CAAC,eAAe,CAAC,SAAS,GAAG,QAAQ,CAAC,IAAI,CAAC,SAAS;aACnF;YACD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC;YAChE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,SAAS,CAAC,GAAG,GAAG,MAAM,CAAC,OAAO,CAAC;QACnE,CAAC,EACD,KAAK,CACR;IACL,CAAC;IAKO,eAAe;QACnB,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAC1B,WAAW,EACX,CAAC,EAAc,EAAE,EAAE;YACf,EAAE,GAAG,EAAE,IAAI,MAAM,CAAC,KAAK;YACvB,IAAI,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE;gBACjB,IAAI,CAAC,SAAS,GAAG,IAAI;aACxB;QACL,CAAC,EACD,KAAK,CACR;IACL,CAAC;IAKO,aAAa;QACjB,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAC1B,SAAS,EACT,CAAC,EAAc,EAAE,EAAE;YACf,EAAE,GAAG,EAAE,IAAI,MAAM,CAAC,KAAK;YACvB,IAAI,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE;gBACjB,IAAI,CAAC,SAAS,GAAG,KAAK;aACzB;QACL,CAAC,EACD,KAAK,CACR;IACL,CAAC;IAMM,KAAK,CAAC,EAA0E;QACnF,QAAQ,CAAC,SAAS,GAAG,CAAC,CAAC,EAAE;YACrB,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,OAAO,CAAC;QACxB,CAAC;IACL,CAAC;CACJ;;;;;;;;;;;;;;AChJD;AAAA;AAAA;AAAA,kJAAkJ;AAU3I,MAAM,GAAG;IAQd,MAAM,CAAC,MAAM,CAAE,CAAQ,EAAE,CAAQ,EAAE,SAAS,GAAC,OAAO;QAClD,OAAO,IAAI,CAAC,GAAG,CAAE,CAAC,GAAC,CAAC,CAAE,GAAG,SAAS,CAAC;IACrC,CAAC;IASD,MAAM,CAAC,IAAI,CAAE,CAAQ,EAAE,CAAQ,EAAE,CAAQ;QACvC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7B,CAAC;IASD,MAAM,CAAC,KAAK,CAAE,GAAU,EAAE,GAAU,EAAE,GAAU;QAC9C,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;IAC3C,CAAC;IA2BD,MAAM,CAAC,MAAM,CAAE,CAAQ,EAAE,CAAQ,EAAE,CAAQ;QACzC,OAAO,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACpD,CAAC;IAQD,MAAM,CAAC,WAAW,CAAE,CAAQ,EAAE,IAAW,CAAC;QACxC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;QACtC,OAAO,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAC/B,CAAC;CAkEF;AAOM,MAAM,IAAI;CA2wBhB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACt6BD,MAAM,YAAY;IACd,MAAM,CAAC,GAAG,CAAC,KAAa,EAAE,KAAa;QACnC,OAAO,IAAI,MAAM,CACb,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EACjB,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,EACjB,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CACpB;IACL,CAAC;CACJ;AAEM,MAAM,MAAO,SAAQ,YAAY;IAwBpC,YAAY,CAAU,EAAE,CAAU,EAAE,CAAU;QAC1C,KAAK,EAAE;QAxBX,aAAK,CAAC;QACN,aAAK,CAAC;QACN,aAAK,CAAC;QAuBF,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;QACf,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;QACf,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;IACnB,CAAC;IAxBD,IAAI,CAAC;QACD,wCAAc;IAClB,CAAC;IACD,IAAI,CAAC,CAAC,CAAS;QACX,IAAI,OAAO,CAAC,KAAK,QAAQ;YAAE,2BAAI,MAAM,CAAC;IAC1C,CAAC;IACD,IAAI,CAAC;QACD,wCAAc;IAClB,CAAC;IACD,IAAI,CAAC,CAAC,CAAS;QACX,IAAI,OAAO,CAAC,KAAK,QAAQ;YAAE,2BAAI,MAAM,CAAC;IAC1C,CAAC;IACD,IAAI,CAAC;QACD,wCAAc;IAClB,CAAC;IACD,IAAI,CAAC,CAAC,CAAS;QACX,IAAI,OAAO,CAAC,KAAK,QAAQ;YAAE,2BAAI,MAAM,CAAC;IAC1C,CAAC;IASD,GAAG,CAAC,CAAU,EAAE,CAAU,EAAE,CAAU;QAClC,IAAI,CAAC,CAAC,GAAG,OAAO,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAI,CAAC,CAAC,GAAG,OAAO,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAC3C,IAAI,CAAC,CAAC,GAAG,OAAO,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QAC3C,OAAO,IAAI;IACf,CAAC;IAED,IAAI;QACA,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;IAC7C,CAAC;IAED,GAAG,CAAC,CAAmB,EAAE,CAAU,EAAE,CAAU;QAC3C,IAAI,CAAC,YAAY,MAAM,EAAE;YACrB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YAClB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YAClB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YAClB,OAAO,IAAI;SACd;QACD,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAChB,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAChB,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAChB,OAAO,IAAI;IACf,CAAC;IAED,GAAG,CAAC,CAAmB,EAAE,CAAU,EAAE,CAAU;QAC3C,IAAI,CAAC,YAAY,MAAM,EAAE;YACrB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YAClB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YAClB,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;YAClB,OAAO,IAAI;SACd;QACD,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAChB,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAChB,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAChB,OAAO,IAAI;IACf,CAAC;IAED,IAAI,CAAC,CAAS;QACV,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,QAAQ,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;YACzC,OAAO,CAAC,IAAI,CAAE,uCAAuC,CAAE;YACvD,OAAO,IAAI;SACd;QACD,IAAI,CAAC,CAAC,IAAI,CAAC;QACX,IAAI,CAAC,CAAC,IAAI,CAAC;QACX,IAAI,CAAC,CAAC,IAAI,CAAC;QACX,OAAO,IAAI;IACf,CAAC;IAED,GAAG,CAAC,CAAS;QACT,IAAI,CAAC,CAAC,OAAO,CAAC,KAAK,QAAQ,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;YACzC,OAAO,CAAC,IAAI,CAAE,uCAAuC,CAAE;YACvD,OAAO,IAAI;SACd;QACD,IAAI,CAAC,KAAK,CAAC,EAAE;YACT,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACvB,OAAO,IAAI,CAAC;SACf;QACD,IAAI,CAAC,CAAC,IAAI,CAAC;QACX,IAAI,CAAC,CAAC,IAAI,CAAC;QACX,IAAI,CAAC,CAAC,IAAI,CAAC;QACX,OAAO,IAAI;IACf,CAAC;IAED,IAAI,CAAC,CAAkB,EAAE,CAAS,EAAE,CAAS;QACzC,IAAI,CAAC,YAAY,MAAM,EAAE;YACrB,OAAO,IAAI,CAAC,IAAI,CACZ,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;gBACzB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;gBACzB,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAC5B;SACJ;QACD,OAAO,IAAI,CAAC,IAAI,CACZ,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;YACvB,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;YACvB,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAC1B;IACL,CAAC;IAED,GAAG;QACC,OAAO,IAAI,CAAC,IAAI,CACZ,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;YACnB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;YACnB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CACtB;IACL,CAAC;IAED,KAAK;IAEL,CAAC;CACJ","file":"draw.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"draw\"] = factory();\n\telse\n\t\troot[\"draw\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","import { Idraw, Isetup } from './types'\r\nimport { Input } from './input'\r\nimport { Vector } from './vector'\r\n\r\nexport class Draw extends Input implements Idraw {\r\n\r\n    #canvas!: HTMLCanvasElement\r\n    #ctx!: CanvasRenderingContext2D\r\n\r\n    setupParams!: (ctx: CanvasRenderingContext2D) => void\r\n    loopParams!: (ctx: CanvasRenderingContext2D) => void\r\n\r\n    get width() { return this.#canvas.width }\r\n    set width(w: number) { this.#canvas.width = w }\r\n\r\n    get height() { return this.#canvas.height }\r\n    set height(h: number) { this.#canvas.height = h }\r\n\r\n    public frame = 0\r\n\r\n    #preloadLeftCount = 0\r\n\r\n    constructor(params?: Isetup) {\r\n        super()\r\n\r\n        this.canvasElementInit(params)\r\n\r\n        this.canvasSizeInit(params)\r\n\r\n        this.mouseEventInit(this.#canvas)\r\n    }\r\n\r\n    private canvasElementInit(params?: Isetup) {\r\n        const { canvasId } = params || {}\r\n        if (canvasId) {\r\n            const canvas = document.getElementById(canvasId) as HTMLCanvasElement\r\n            if (canvas !== null) this.#canvas = canvas\r\n            else this.#canvas = this._createElement(\"canvas\") as HTMLCanvasElement\r\n        }\r\n        else {\r\n            this.#canvas = this._createElement(\"canvas\") as HTMLCanvasElement\r\n            document.body.appendChild(this.#canvas)\r\n        }\r\n        this.#ctx = this.#canvas.getContext('2d') as CanvasRenderingContext2D\r\n    }\r\n\r\n    private canvasSizeInit(params?: Isetup) {\r\n        const { width, height } = params || {}\r\n        this.width = width || 1000\r\n        this.height = height || 1000\r\n    }\r\n\r\n    /**\r\n    * Helper function to create a DOM element\r\n    * @param elem element tag name\r\n    */\r\n    protected _createElement(elem = \"div\"): HTMLElement {\r\n        const d = document.createElement(elem)\r\n        return d\r\n    }\r\n\r\n    public preload(cb: () => void) {\r\n        cb()\r\n    }\r\n\r\n    /**\r\n     * Setup only call once\r\n     * @param cb Function to be called at initialization time\r\n     */\r\n    public setup(cb: (ctx: CanvasRenderingContext2D) => void) {\r\n        if (!this.setupParams) {\r\n            this.setupParams = cb\r\n        }\r\n        \r\n        if (this.#preloadLeftCount > 0) return\r\n        \r\n        if (cb) cb(this.#ctx)\r\n    }\r\n\r\n    /**\r\n     * Loop each frame\r\n     * @param cb function for each frame call\r\n     */\r\n    public loop(cb: (ctx: CanvasRenderingContext2D) => void) {\r\n        if (!this.loopParams) {\r\n            this.loopParams = cb\r\n        }\r\n        \r\n        if (this.#preloadLeftCount > 0) return\r\n\r\n        if (document.hidden === true) {\r\n            requestAnimationFrame(this.loop.bind(this, cb))\r\n            return\r\n        }\r\n        this.frame++\r\n        const mousePos = new Vector(this.mouseX, this.mouseY)\r\n        this.pushMousePosHistory(mousePos)\r\n        if (cb) cb(this.#ctx)\r\n        else throw Error('without callback')\r\n        requestAnimationFrame(this.loop.bind(this, cb))\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param width stroke width\r\n     */\r\n    public strokeWeight(width: number) {\r\n        this.#ctx.lineWidth = width\r\n    }\r\n\r\n    /**\r\n     * Trace the path\r\n     */\r\n    private stroke() {\r\n        this.#ctx.stroke()\r\n    }\r\n\r\n    private beginPath() {\r\n        this.#ctx.beginPath()\r\n    }\r\n\r\n    private closePath() {\r\n        this.#ctx.closePath()\r\n    }\r\n\r\n    /**\r\n     * Draw lines\r\n     * @param x1 X coordinate of the starting point\r\n     * @param y1 Y coordinate of the starting point\r\n     * @param x2 X coordinate of the ending point\r\n     * @param y2 Y coordinate of the ending point\r\n     */\r\n    public line(x1: number, y1: number, x2: number, y2: number) {\r\n        this.beginPath()\r\n        this.#ctx.moveTo(x1, y1)\r\n        this.#ctx.lineTo(x2, y2)\r\n        this.closePath()\r\n        this.stroke()\r\n    }\r\n\r\n    public clear() {\r\n        this.#ctx.clearRect(0, 0, this.width, this.height)\r\n    }\r\n    \r\n    async loadMedia(path: string) {\r\n        this.#preloadLeftCount ++\r\n        const res = await this.sleep(2000)\r\n        this.#preloadLeftCount --\r\n        if (this.#preloadLeftCount === 0) {\r\n            this.setup(this.setupParams)\r\n            this.loop(this.loopParams)\r\n        }\r\n    }\r\n\r\n    loadImage(path: string) {\r\n        return this.loadMedia(path)\r\n    }\r\n\r\n    sleep(time: number) {\r\n        return new Promise(r => {\r\n            setTimeout(() => {\r\n                r()\r\n            }, time);\r\n        })\r\n    }\r\n}","import { Draw } from './canvas'\r\nimport { Num, Geom } from './num'\r\nimport { Vector } from './vector'\r\n\r\nwindow.Draw = Draw\r\n\r\nwindow.Num = Num\r\n\r\nwindow.Geom = Geom\r\n\r\nwindow.Vector = Vector","import { Vector } from './vector'\r\n\r\nexport class Input {\r\n\r\n    #canvas!: HTMLCanvasElement\r\n    #mousePos = new Vector()\r\n\r\n    #mouseHistoryCount = 10\r\n    public frame = 0\r\n    public frameLock = 0\r\n\r\n    get mouseX() {\r\n        return this.#mousePos.x\r\n    }\r\n    set mouseX(x: number) {\r\n        this.#mousePos.x = x\r\n    }\r\n    get mouseY() {\r\n        return this.#mousePos.y\r\n    }\r\n    set mouseY(y: number) {\r\n        this.#mousePos.y = y\r\n    }\r\n\r\n    get pmouseX() {\r\n        const len = this.mousePosHistory.length\r\n        if (len > 2) {\r\n            return this.mousePosHistory[1].x\r\n        }\r\n        else if (len === 1) {\r\n            return this.mousePosHistory[0].x\r\n        }\r\n        return this.mouseX\r\n    }\r\n\r\n    get pmouseY() {\r\n        const len = this.mousePosHistory.length\r\n        if (len > 2) {\r\n            return this.mousePosHistory[1].y\r\n        }\r\n        else if (len === 1) {\r\n            return this.mousePosHistory[0].y\r\n        }\r\n        return this.mouseY\r\n    }\r\n\r\n    public mousePosHistory: Vector[] = []\r\n\r\n    public mouseDown = false\r\n\r\n    get canvasPos() {\r\n        const pos = this.#canvas.getBoundingClientRect()\r\n        return {\r\n            left: pos.left,\r\n            top: pos.top,\r\n            right: pos.right,\r\n            bottom: pos.bottom\r\n        }\r\n    }\r\n\r\n    public setMouseHistoryCount(count: number): void {\r\n        this.#mouseHistoryCount = count\r\n    }\r\n\r\n    protected pushMousePosHistory(currentMousePos: Vector): void {\r\n        this.mousePosHistory.unshift(currentMousePos)\r\n        if (this.mousePosHistory.length > this.#mouseHistoryCount) {\r\n            this.mousePosHistory.pop()\r\n        }\r\n    }\r\n\r\n    protected mouseEventInit(canvas: HTMLCanvasElement): void {\r\n\r\n        this.#canvas = canvas\r\n\r\n        this.onmousemoveInit()\r\n        this.onmousedownInit()\r\n        this.onmouseupInit()\r\n    }\r\n\r\n    /**\r\n     * onMouseMove event of canvas element\r\n     */\r\n    private onmousemoveInit(): void {\r\n        this.#canvas.addEventListener(\r\n            'mousemove',\r\n            (ev: MouseEvent) => {\r\n                const canvasPos = this.canvasPos\r\n                let posX = 0, posY = 0\r\n                if (ev.pageX) {\r\n                    posX = ev.pageX\r\n                    posY = ev.pageY\r\n                } else if (ev.clientX) {\r\n                    posX = ev.clientX + document.documentElement.scrollLeft + document.body.scrollLeft\r\n                    posY = ev.clientY + document.documentElement.scrollTop + document.body.scrollTop\r\n                }\r\n                this.mouseX = Math.round(posX - canvasPos.left - window.scrollX)\r\n                this.mouseY = Math.round(posY - canvasPos.top - window.scrollY)\r\n            },\r\n            false\r\n        )\r\n    }\r\n\r\n    /**\r\n     * onmousedown event of document\r\n     */\r\n    private onmousedownInit(): void {\r\n        document.body.addEventListener(\r\n            'mousedown',\r\n            (ev: MouseEvent) => {\r\n                ev = ev || window.event\r\n                if (ev.button === 0) {\r\n                    this.mouseDown = true\r\n                }\r\n            },\r\n            false\r\n        )\r\n    }\r\n\r\n    /**\r\n     * onmouseup event of document\r\n     */\r\n    private onmouseupInit(): void {\r\n        document.body.addEventListener(\r\n            'mouseup',\r\n            (ev: MouseEvent) => {\r\n                ev = ev || window.event\r\n                if (ev.button === 0) {\r\n                    this.mouseDown = false\r\n                }\r\n            },\r\n            false\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Register mouse down events\r\n     * @param cb Function triggered on mouse down\r\n     */\r\n    public click(cb: (key: KeyboardEvent['key'], keyCode: KeyboardEvent['keyCode']) => void) {\r\n        document.onkeydown = e => {\r\n            cb(e.key, e.keyCode)\r\n        }\r\n    }\r\n}","/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\r\n\r\n// import { Const } from \"./Util\";\r\n// import { Curve } from \"./Op\";\r\n// import { Pt, Group } from \"./Pt\";\r\n// import { Vec, Mat } from \"./LinearAlgebra\";\r\n// import {PtLike, GroupLike} from \"./Types\";\r\n/**\r\n * Num class provides static helper functions for basic numeric operations.\r\n */\r\nexport class Num {\r\n\r\n  /**\r\n   * Check if two numbers are equal or almost equal within a threshold.\r\n   * @param a number a\r\n   * @param b number b\r\n   * @param threshold threshold value that specifies the minimum difference within which the two numbers are considered equal\r\n   */\r\n  static equals( a:number, b:number, threshold=0.00001 ):boolean {\r\n    return Math.abs( a-b ) < threshold;\r\n  }\r\n\r\n\r\n  /**\r\n   * Calculate linear interpolation between 2 values.\r\n   * @param a start value\r\n   * @param b end value\r\n   * @param t an interpolation value, usually between 0 to 1\r\n   */\r\n  static lerp( a:number, b:number, t:number ):number {\r\n    return (1 - t) * a + t * b;\r\n  }\r\n\r\n\r\n  /**\r\n   * Clamp values between min and max.\r\n   * @param val value to clamp\r\n   * @param min min value\r\n   * @param max max value\r\n   */\r\n  static clamp( val:number, min:number, max:number ):number {\r\n    return Math.max(min, Math.min(max, val));\r\n  }\r\n\r\n\r\n//   /**\r\n//    * Different from [`Num.clamp`](#link) in that the value out-of-bound will be \"looped back\" to the other end.\r\n//    * @param val value to bound\r\n//    * @param min min value\r\n//    * @param max max value\r\n//    * @example `boundValue(361, 0, 360)` will return 1\r\n//    */\r\n//   boundValue( val:number, min:number, max:number ):number {\r\n//     let len = Math.abs(max - min);\r\n//     let a = val % len;\r\n\r\n//     if (a > max) a -= len;\r\n//     else if (a < min) a += len;\r\n\r\n//     return a;\r\n//   },\r\n\r\n\r\n  /**\r\n   * Check if a value is within two other values\r\n   * @param p value to check\r\n   * @param a first bounding value\r\n   * @param b second bounding value\r\n   */\r\n  static within( p:number, a:number, b:number ):boolean {\r\n    return p >= Math.min(a, b) && p <= Math.max(a, b);\r\n  }\r\n\r\n\r\n  /**\r\n   * Get a random number within a range.\r\n   * @param a range value 1\r\n   * @param b range value 2\r\n   */\r\n  static randomRange( a:number, b:number = 0 ):number {\r\n    const r = (a > b) ? (a - b) : (b - a);\r\n    return a + Math.random() * r;\r\n  }\r\n\r\n\r\n//   /**\r\n//    * Normalize a value within a range.\r\n//    * @param n the value to normalize\r\n//    * @param a range value 1\r\n//    * @param b range value 1\r\n//    */\r\n//   normalizeValue(n:number, a:number, b:number):number {\r\n//     const min = Math.min(a, b);\r\n//     const max = Math.max(a, b);\r\n//     return (n - min) / (max - min);\r\n//   },\r\n\r\n\r\n//   /**\r\n//    * Sum a group of numeric arrays.\r\n//    * @param pts an array of numeric arrays\r\n//    * @returns a Pt of the dimensional sums\r\n//    */\r\n//   sum(pts: GroupLike|number[][]): Pt {\r\n//     let c = new Pt( pts[0] );\r\n//     for (let i = 1, len = pts.length; i < len; i++) {\r\n//       Vec.add(c, pts[i]);\r\n//     }\r\n//     return c;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Average a group of numeric arrays\r\n//    * @param pts an array of numeric arrays\r\n//    * @returns a Pt of averages\r\n//    */\r\n//   static average(pts: GroupLike|number[][]): Pt {\r\n//     return Num.sum(pts).divide(pts.length);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Given a value between 0 to 1, returns a value that cycles between 0 -> 1 -> 0 using the provided shaping method.\r\n//    * @param t a value between 0 to 1\r\n//    * @param method a shaping method. Default to [`Shaping.sineInOut`](#link).\r\n//    * @return a value between 0 to 1\r\n//    */\r\n//   static cycle( t:number, method:(t:number) => number=Shaping.sineInOut ):number {\r\n//     return method( t > 0.5 ? 2-t*2 : t*2 );\r\n//   }\r\n\r\n\r\n//   /**  \r\n//    * Map a value from one range to another.\r\n//    * @param n a value in the first range\r\n//    * @param currMin lower bound of the first range\r\n//    * @param currMax upper bound of the first range\r\n//    * @param targetMin lower bound of the second range\r\n//    * @param targetMax upper bound of the second range\r\n//    * @returns a remapped value in the second range\r\n//    */\r\n//   static mapToRange(n:number, currA:number, currB:number, targetA:number, targetB:number) {\r\n//     if (currA == currB) throw new Error(\"[currMin, currMax] must define a range that is not zero\");\r\n//     let min = Math.min(targetA, targetB);\r\n//     let max = Math.max(targetA, targetB);\r\n//     return Num.normalizeValue(n, currA, currB) * (max - min) + min;\r\n//   }\r\n}\r\n\r\n\r\n\r\n// /**\r\n//  * Geom class provides static helper functions for basic geometric operations.\r\n//  */\r\nexport class Geom {\r\n//   /**\r\n//    * Bound an angle between 0 to 360 degrees.\r\n//    * @param angle angle value\r\n//    */\r\n//   static boundAngle( angle:number ):number {\r\n//     return Num.boundValue(angle, 0, 360);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Bound a radian between 0 to two PI.\r\n//    * @param radian radian value\r\n//    */\r\n//   static boundRadian( radian:number ):number {\r\n//     return Num.boundValue(radian, 0, Const.two_pi);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Convert an angle in degree to radian.\r\n//    * @param angle angle value\r\n//    */\r\n//   static toRadian( angle:number ):number {\r\n//     return angle * Const.deg_to_rad;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Convert an angle in radian to degree.\r\n//    * @param radian radian value\r\n//    */\r\n//   static toDegree( radian:number ):number {\r\n//     return radian * Const.rad_to_deg;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Get a bounding box for a set of Pts.\r\n//    * @param pts a Group or an array of Pts\r\n//    * @return a Group of two Pts, representing the top-left and bottom-right corners\r\n//    */\r\n//   static boundingBox( pts:GroupLike ): Group {\r\n//     let minPt = pts.reduce((a: Pt, p: Pt) => a.$min(p));\r\n//     let maxPt = pts.reduce((a: Pt, p: Pt) => a.$max(p));\r\n//     return new Group(minPt, maxPt);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Get a centroid (the average middle point) for a set of Pts.\r\n//    * @param pts a Group or an array of Pts\r\n//    * @return a centroid Pt \r\n//    */\r\n//   static centroid( pts:GroupLike|number[][] ):Pt {\r\n//     return Num.average(pts);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Given an anchor Pt, rebase all Pts in this group either to or from this anchor base.\r\n//    * @param pts a Group or array of Pt\r\n//    * @param ptOrIndex an index for the Pt array, or an external Pt\r\n//    * @param direction a string either \"to\" (subtract all Pt with this anchor base), or \"from\" (add all Pt from this anchor base)\r\n//    */\r\n//   static anchor( pts:GroupLike, ptOrIndex:PtLike|number=0, direction:(\"to\"|\"from\")=\"to\") {\r\n//     let method = (direction == \"to\") ? \"subtract\" : \"add\";\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       if (typeof ptOrIndex == \"number\") {\r\n//         if (ptOrIndex !== i) pts[i][method](pts[ptOrIndex]);\r\n//       } else {\r\n//         pts[i][method](ptOrIndex);\r\n//       }\r\n//     }\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Get an interpolated (or extrapolated) value between two Pts. For linear interpolation between 2 scalar values, use [`Num.lerp`](#link).\r\n//    * @param a first Pt\r\n//    * @param b second Pt\r\n//    * @param t a value between 0 to 1 to interpolate, or any other value to extrapolate\r\n//    * @returns interpolated point as a new Pt\r\n//    */\r\n//   static interpolate( a:Pt|number[], b:Pt|number[], t:number=0.5 ):Pt {\r\n//     let len = Math.min(a.length, b.length);\r\n//     let d = Pt.make(len);\r\n//     for (let i = 0; i < len; i++) {\r\n//       d[i] = a[i] * (1 - t) + b[i] * t;\r\n//     }\r\n//     return d;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Find two Pts that are perpendicular to this Pt (2D only).\r\n//    * @param axis a string such as \"xy\" (use Const.xy) or an array to specify index for two dimensions\r\n//    * @returns an array of two Pt that are perpendicular to this Pt\r\n//    */\r\n//   static perpendicular( pt:PtLike, axis:string|number[]=Const.xy ):Group {\r\n//     let y = axis[1];\r\n//     let x = axis[0];\r\n\r\n//     let p = new Pt(pt);\r\n//     let pa = new Pt(p);\r\n//     pa[x] = -p[y];\r\n//     pa[y] = p[x];\r\n//     let pb = new Pt(p);\r\n//     pb[x] = p[y];\r\n//     pb[y] = -p[x];\r\n\r\n//     return new Group(pa, pb);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Check if two Pts are perpendicular to each other (2D only).\r\n//    */\r\n//   static isPerpendicular( p1:PtLike, p2:PtLike ):boolean {\r\n//     return new Pt(p1).dot(p2) === 0;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Check if a Pt is within the rectangular boundary defined by two Pts.\r\n//    * @param pt the Pt to check\r\n//    * @param boundPt1 boundary Pt 1\r\n//    * @param boundPt2 boundary Pt 2\r\n//    */\r\n//   static withinBound( pt:PtLike|number[], boundPt1:PtLike|number[], boundPt2:PtLike|number[] ):boolean {\r\n//     for (let i = 0, len = Math.min(pt.length, boundPt1.length, boundPt2.length); i < len; i++) {\r\n//       if (!Num.within(pt[i], boundPt1[i], boundPt2[i])) return false;\r\n//     }\r\n//     return true;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Sort the Pts so that their edges will form a non-overlapping polygon. ([Reference](https://stackoverflow.com/questions/6989100/sort-points-in-clockwise-order))\r\n//    * @param pts an array of Pts\r\n//    */\r\n//   static sortEdges( pts:GroupLike ):GroupLike {\r\n\r\n//     let bounds = Geom.boundingBox( pts );\r\n//     let center = bounds[1].add(bounds[0]).divide(2);\r\n    \r\n//     let fn = ( a:Pt, b:Pt ):number => {\r\n//       if (a.length < 2 || b.length < 2) throw new Error( \"Pt dimension cannot be less than 2\");\r\n\r\n//       let da = a.$subtract( center );\r\n//       let db = b.$subtract( center );\r\n      \r\n//       if (da[0] >= 0 && db[0] < 0) return 1;\r\n//       if (da[0] < 0 && db[0] >= 0) return -1;\r\n//       if (da[0] == 0 && db[0] == 0) {\r\n//           if (da[1] >= 0 || db[1] >= 0)\r\n//               return (da[1] > db[1]) ? 1 : -1;\r\n//           return (db[1] > da[1]) ? 1 : -1;\r\n//       }\r\n\r\n//       // compute the cross product of vectors (center -> a) x (center -> b)\r\n//       let det = da.$cross2D( db );\r\n//       if (det < 0) return 1;\r\n//       if (det > 0) return -1;\r\n      \r\n//       // points a and b are on the same line from the center\r\n//       // check which point is closer to the center\r\n//       return (da[0]*da[0] + da[1]*da[1] > db[0]*db[0] + db[1]*db[1]) ? 1 : -1;\r\n//     };\r\n\r\n//     return pts.sort( fn );\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Scale a Pt or a Group of Pts. You may also use [`Pt.scale`](#link) instance method.\r\n//    * @param ps a Pt or a Group of Pts\r\n//    * @param scale scale value\r\n//    * @param anchor optional anchor point to scale from\r\n//    */\r\n//   static scale( ps:Pt|GroupLike, scale:number|number[]|PtLike, anchor?:PtLike ):Geom {\r\n//     let pts = (!Array.isArray(ps)) ? [ps] : ps;\r\n//     let scs = (typeof scale == \"number\") ? Pt.make(pts[0].length, scale) : scale;\r\n//     if (!anchor) anchor = Pt.make(pts[0].length, 0);\r\n\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       let p = pts[i];\r\n//       for (let k = 0, lenP = p.length; k < lenP; k++) {\r\n//         p[k] = (anchor && anchor[k]) ? anchor[k] + (p[k] - anchor[k]) * scs[k] : p[k] * scs[k];\r\n//       }\r\n//     }\r\n\r\n//     return Geom;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Rotate a Pt or a Group of Pts in 2D space. You may also use [`Pt.rotate2D`](#link) instance method.\r\n//    * @param ps a Pt or a Group of Pts\r\n//    * @param angle rotate angle\r\n//    * @param anchor optional anchor point to rotate from\r\n//    * @param axis optional axis such as \"xy\" (use Const.xy) to define a 2D plane, or a number array to specify indices\r\n//    */\r\n//   static rotate2D( ps:Pt|GroupLike, angle:number, anchor?:PtLike, axis?:string|number[] ):Geom {\r\n//     let pts = (!Array.isArray(ps)) ? [ps] : ps;\r\n//     let fn = (anchor) ? Mat.rotateAt2DMatrix : Mat.rotate2DMatrix;\r\n//     if (!anchor) anchor = Pt.make(pts[0].length, 0);\r\n//     let cos = Math.cos(angle);\r\n//     let sin = Math.sin(angle);\r\n\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       let p = (axis) ? pts[i].$take(axis) : pts[i];\r\n//       p.to(Mat.transform2D(p, fn(cos, sin, anchor)));\r\n//       if (axis) {\r\n//         for (let k = 0; k < axis.length; k++) {\r\n//           pts[i][axis[k]] = p[k];\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return Geom;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Shear a Pt or a Group of Pts in 2D space. You may also use [`Pt.shear2D`](#link) instance method.\r\n//    * @param ps a Pt or a Group of Pts\r\n//    * @param scale shearing value which can be a number or an array of 2 numbers\r\n//    * @param anchor optional anchor point to shear from\r\n//    * @param axis optional axis such as \"xy\" (use Const.xy) to define a 2D plane, or a number array to specify indices\r\n//    */\r\n//   static shear2D( ps:Pt|GroupLike, scale:number|number[]|PtLike, anchor?:PtLike, axis?:string|number[] ):Geom {\r\n//     let pts = (!Array.isArray(ps)) ? [ps] : ps;\r\n//     let s = (typeof scale == \"number\") ? [scale, scale] : scale;\r\n//     if (!anchor) anchor = Pt.make(pts[0].length, 0);\r\n//     let fn = (anchor) ? Mat.shearAt2DMatrix : Mat.shear2DMatrix;\r\n//     let tanx = Math.tan(s[0]);\r\n//     let tany = Math.tan(s[1]);\r\n\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       let p = (axis) ? pts[i].$take(axis) : pts[i];\r\n//       p.to(Mat.transform2D(p, fn(tanx, tany, anchor)));\r\n//       if (axis) {\r\n//         for (let k = 0; k < axis.length; k++) {\r\n//           pts[i][axis[k]] = p[k];\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return Geom;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Reflect a Pt or a Group of Pts along a 2D line. You may also use [`Pt.reflect2D`](#link) instance method.\r\n//    * @param ps a Pt or a Group of Pts\r\n//    * @param line a Group of 2 Pts that defines a line for reflection\r\n//    * @param axis optional axis such as \"xy\" (use Const.xy) to define a 2D plane, or a number array to specify indices\r\n//    */\r\n//   static reflect2D( ps:Pt|GroupLike, line:GroupLike, axis?:string|number[] ):Geom {\r\n//     let pts = (!Array.isArray(ps)) ? [ps] : ps;\r\n//     let mat = Mat.reflectAt2DMatrix(line[0], line[1]);\r\n\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       let p = (axis) ? pts[i].$take(axis) : pts[i];\r\n//       p.to(Mat.transform2D(p, mat));\r\n//       if (axis) {\r\n//         for (let k = 0; k < axis.length; k++) {\r\n//           pts[i][axis[k]] = p[k];\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return Geom;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Generate a cosine lookup table.\r\n//    * @returns an object with a cosine tables (array of 360 values) and a function to get cosine given a radian input. \r\n//    */\r\n//   static cosTable() {\r\n//     let cos = new Float64Array(360);\r\n\r\n//     for (let i = 0; i < 360; i++) cos[i] = Math.cos(i * Math.PI / 180);\r\n//     let find = (rad:number) => cos[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\r\n\r\n//     return { table: cos, cos: find };\r\n//   }\r\n\r\n//   /**\r\n//    * Generate a sine lookup table.\r\n//    * @returns an object with a sine tables (array of 360 values) and a function to get sine value given a radian input. \r\n//    */\r\n//   static sinTable() {\r\n//     let sin = new Float64Array(360);\r\n\r\n//     for (let i = 0; i < 360; i++) sin[i] = Math.sin(i * Math.PI / 180);\r\n//     let find = (rad:number) => sin[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\r\n\r\n//     return { table: sin, sin: find };\r\n//   }\r\n// }\r\n\r\n\r\n\r\n// /**\r\n//  * Shaping provides shaping functions to interpolate a value. These are useful for easing and transitions.\r\n//  */\r\n// export class Shaping {\r\n\r\n//   /**\r\n//    * Linear mapping.\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static linear(t:number, c:number = 1):number {\r\n//     return c * t;\r\n//   }\r\n\r\n//   /** \r\n//    * Quadratic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//   */\r\n//   static quadraticIn(t:number, c:number = 1):number {\r\n//     return c * t * t;\r\n//   }\r\n\r\n//   /** \r\n//    * Quadratic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//   */\r\n//   static quadraticOut(t:number, c:number = 1):number {\r\n//     return -c * t * (t - 2);\r\n//   }\r\n\r\n//   /** \r\n//    * Quadratic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static quadraticInOut(t:number, c:number = 1):number {\r\n//     let dt = t * 2;\r\n//     return (t < 0.5) ? c / 2 * t * t * 4 : -c / 2 * ((dt - 1) * (dt - 3) - 1);\r\n//   }\r\n\r\n//   /** \r\n//    * Cubic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static cubicIn(t:number, c:number = 1):number {\r\n//     return c * t * t * t;\r\n//   }\r\n\r\n//   /** \r\n//    * Cubic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static cubicOut(t:number, c:number = 1):number {\r\n//     let dt = t - 1;\r\n//     return c * (dt * dt * dt + 1);\r\n//   }\r\n\r\n//   /** \r\n//    * Cubic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static cubicInOut(t:number, c:number = 1):number {\r\n//     let dt = t * 2;\r\n//     return (t < 0.5) ? c / 2 * dt * dt * dt : c / 2 * ((dt - 2) * (dt - 2) * (dt - 2) + 2);\r\n//   }\r\n\r\n//   /** \r\n//    * Exponential ease in, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p a value between 0 to 1 to control the curve. Default is 0.25.\r\n//    */\r\n//   static exponentialIn(t:number, c:number = 1, p:number = 0.25):number {\r\n//     return c * Math.pow(t, 1 / p);\r\n//   }\r\n\r\n//   /** \r\n//    * Exponential ease out, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p a value between 0 to 1 to control the curve. Default is 0.25.\r\n//    */\r\n//   static exponentialOut(t:number, c:number = 1, p:number = 0.25):number {\r\n//     return c * Math.pow(t, p);\r\n//   }\r\n\r\n//   /** \r\n//    * Sinuous in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static sineIn(t:number, c:number = 1):number {\r\n//     return -c * Math.cos(t * Const.half_pi) + c;\r\n//   }\r\n\r\n//   /** \r\n//    * Sinuous out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static sineOut(t:number, c:number = 1):number {\r\n//     return c * Math.sin(t * Const.half_pi);\r\n//   }\r\n\r\n//   /** \r\n//    * Sinuous in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static sineInOut(t:number, c:number = 1):number {\r\n//     return -c / 2 * (Math.cos(Math.PI * t) - 1);\r\n//   }\r\n\r\n//   /** \r\n//    * A faster way to approximate cosine ease in-out using Blinn-Wyvill Approximation. Adapated from Golan Levin's [polynomial shaping](http://www.flong.com/texts/code/shapers_poly/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static cosineApprox(t:number, c:number = 1) {\r\n//     let t2 = t * t;\r\n//     let t4 = t2 * t2;\r\n//     let t6 = t4 * t2;\r\n//     return c * (4 * t6 / 9 - 17 * t4 / 9 + 22 * t2 / 9);\r\n//   }\r\n\r\n//   /** \r\n//    * Circular in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static circularIn(t:number, c:number = 1):number {\r\n//     return -c * (Math.sqrt(1 - t * t) - 1);\r\n//   }\r\n\r\n//   /** \r\n//    * Circular out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static circularOut(t:number, c:number = 1):number {\r\n//     let dt = t - 1;\r\n//     return c * Math.sqrt(1 - dt * dt);\r\n//   }\r\n\r\n//   /** \r\n//    * Circular in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static circularInOut(t:number, c:number = 1):number {\r\n//     let dt = t * 2;\r\n//     return (t < 0.5) ? -c / 2 * (Math.sqrt(1 - dt * dt) - 1) : c / 2 * (Math.sqrt(1 - (dt - 2) * (dt - 2)) + 1);\r\n//   }\r\n\r\n//   /** \r\n//    * Elastic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.\r\n//    */\r\n//   static elasticIn(t:number, c:number = 1, p:number = 0.7):number {\r\n//     let dt = t - 1;\r\n//     let s = (p / Const.two_pi) * 1.5707963267948966;\r\n//     return c * (-Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p));\r\n//   }\r\n\r\n//   /** \r\n//    * Elastic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.\r\n//    */\r\n//   static elasticOut(t:number, c:number = 1, p:number = 0.7):number {\r\n//     let s = (p / Const.two_pi) * 1.5707963267948966;\r\n//     return c * (Math.pow(2, -10 * t) * Math.sin((t - s) * Const.two_pi / p)) + c;\r\n//   }\r\n\r\n//   /** \r\n//    * Elastic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.6.\r\n//    */\r\n//   static elasticInOut(t:number, c:number = 1, p:number = 0.6):number {\r\n//     let dt = t * 2;\r\n//     let s = (p / Const.two_pi) * 1.5707963267948966;\r\n//     if (t < 0.5) {\r\n//       dt -= 1;\r\n//       return c * (-0.5 * (Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p)));\r\n//     } else {\r\n//       dt -= 1;\r\n//       return c * (0.5 * (Math.pow(2, -10 * dt) * Math.sin((dt - s) * Const.two_pi / p))) + c;\r\n//     }\r\n//   }\r\n\r\n//   /** \r\n//    * Bounce in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static bounceIn(t:number, c:number = 1):number {\r\n//     return c - Shaping.bounceOut((1 - t), c);\r\n//   }\r\n\r\n//   /** \r\n//    * Bounce out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static bounceOut(t:number, c:number = 1) {\r\n//     if (t < (1 / 2.75)) {\r\n//       return c * (7.5625 * t * t);\r\n//     } else if (t < (2 / 2.75)) {\r\n//       t -= 1.5 / 2.75;\r\n//       return c * (7.5625 * t * t + 0.75);\r\n//     } else if (t < (2.5 / 2.75)) {\r\n//       t -= 2.25 / 2.75;\r\n//       return c * (7.5625 * t * t + 0.9375);\r\n//     } else {\r\n//       t -= 2.625 / 2.75;\r\n//       return c * (7.5625 * t * t + 0.984375);\r\n//     }\r\n//   }\r\n\r\n//   /** \r\n//    * Bounce in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static bounceInOut(t:number, c:number = 1):number {\r\n//     return (t < 0.5) ? Shaping.bounceIn(t * 2, c) / 2 : Shaping.bounceOut(t * 2 - 1, c) / 2 + c / 2;\r\n//   }\r\n\r\n//   /** \r\n//    * Sigmoid curve changes its shape adapted from the input value, but always returns a value between 0 to 1.\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p the larger the value, the \"steeper\" the curve will be. Default is 10.\r\n//    */\r\n//   static sigmoid(t:number, c:number = 1, p:number = 10):number {\r\n//     let d = p * (t - 0.5);\r\n//     return c / (1 + Math.exp(-d));\r\n//   }\r\n\r\n//   /** \r\n//    * Logistic sigmoid, adapted from Golan Levin's [shaping function](http://www.flong.com/texts/code/shapers_exp/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.7.\r\n//    */\r\n//   static logSigmoid(t:number, c:number = 1, p:number = 0.7):number {\r\n//     p = Math.max(Const.epsilon, Math.min(1 - Const.epsilon, p));\r\n//     p = 1 / (1 - p);\r\n\r\n//     let A = 1 / (1 + Math.exp(((t - 0.5) * p * -2)));\r\n//     let B = 1 / (1 + Math.exp(p));\r\n//     let C = 1 / (1 + Math.exp(-p));\r\n//     return c * (A - B) / (C - B);\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Exponential seat curve, adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.5.\r\n//    */\r\n//   static seat(t:number, c:number = 1, p:number = 0.5):number {\r\n//     if ((t < 0.5)) {\r\n//       return c * (Math.pow(2 * t, 1 - p)) / 2;\r\n//     } else {\r\n//       return c * (1 - (Math.pow(2 * (1 - t), 1 - p)) / 2);\r\n//     }\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Quadratic bezier curve, adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p1 a Pt object specifying the first control Pt, or a value specifying the control Pt's x position (its y position will default to 0.5). Default is `Pt(0.95, 0.95)\r\n//    */\r\n//   static quadraticBezier(t:number, c:number = 1, p:number|PtLike=[0.05, 0.95] ):number {\r\n//     let a:number = (typeof p != \"number\") ? p[0] : p;\r\n//     let b:number = (typeof p != \"number\") ? p[1] : 0.5;\r\n//     let om2a = 1 - 2 * a;\r\n//     if (om2a === 0) {\r\n//       om2a = Const.epsilon;\r\n//     }\r\n//     let d = (Math.sqrt(a * a + om2a * t) - a) / om2a;\r\n//     return c * ((1 - 2 * b) * (d * d) + (2 * b) * d);\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Cubic bezier curve. This reuses the bezier functions in Curve class.\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p1` a Pt object specifying the first control Pt. Default is `Pt(0.1, 0.7).\r\n//    * @param p2` a Pt object specifying the second control Pt. Default is `Pt(0.9, 0.2).\r\n//    */\r\n//   static cubicBezier(t:number, c:number = 1, p1:PtLike=[0.1, 0.7], p2:PtLike=[0.9, 0.2] ):number {\r\n//     let curve = new Group( new Pt(0, 0), new Pt(p1), new Pt(p2), new Pt(1, 1) );\r\n//     return c * Curve.bezierStep(new Pt(t*t*t, t*t, t, 1), Curve.controlPoints(curve)).y;\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Give a Pt, draw a quadratic curve that will pass through that Pt as closely as possible. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_poly/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p1` a Pt object specifying the Pt to pass through. Default is `Pt(0.2, 0.35)\r\n//    */\r\n//   static quadraticTarget(t:number, c:number = 1, p1:PtLike = [0.2, 0.35]):number {\r\n//     let a = Math.min(1 - Const.epsilon, Math.max( Const.epsilon, p1[0] ));\r\n//     let b = Math.min(1, Math.max( 0, p1[1] ));\r\n//     let A = (1 - b) / (1 - a) - (b / a);\r\n//     let B = (A * (a * a) - b) / a;\r\n//     let y = A * (t * t) - B * t;\r\n//     return c * Math.min(1, Math.max(0, y));\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Step function is a simple jump from 0 to 1 at a specific Pt in time.\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p usually a value between 0 to 1, which specify the Pt to \"jump\". Default is 0.5 which is in the middle.\r\n//    */\r\n//   static cliff(t:number, c:number = 1, p:number = 0.5):number {\r\n//     return (t > p) ? c : 0;\r\n//   }\r\n\r\n//   /** \r\n//    * Convert any shaping functions into a series of steps.\r\n//    * @param fn the original shaping function\r\n//    * @param steps the number of steps\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param args optional paramters to pass to original function\r\n//    */\r\n//   static step(fn: Function, steps:number, t:number, c:number, ...args:any[]) {\r\n//     let s = 1 / steps;\r\n//     let tt = Math.floor(t / s) * s;\r\n//     return fn(tt, c, ...args);\r\n//   }\r\n\r\n// }\r\n\r\n\r\n// /**\r\n//  * Range object keeps track of a Group of n-dimensional Pts to provide its minimum, maximum, and magnitude in each dimension. \r\n//  * It also provides convenient functions such as mapping the Group to another range. This class may be useful for visualizing data in charts.\r\n//  */\r\n// export class Range {\r\n\r\n//   protected _source:Group;\r\n//   protected _max:Pt;\r\n//   protected _min:Pt;\r\n//   protected _mag:Pt;\r\n//   protected _dims:number = 0;\r\n\r\n\r\n//   /**\r\n//    * Construct a Range instance for a Group of Pts.\r\n//    * @param g a Group or an array of Pts\r\n//    */\r\n//   constructor( g:GroupLike ) {\r\n//     this._source = Group.fromPtArray( g );\r\n//     this.calc();\r\n//   }\r\n\r\n//   /**\r\n//    * Get this Range's maximum values per dimension.\r\n//    */\r\n//   get max():Pt { return this._max.clone(); }\r\n  \r\n//   /**\r\n//    * Get this Range's minimum values per dimension.\r\n//    */\r\n//   get min():Pt { return this._min.clone(); }\r\n  \r\n//   /**\r\n//    * Get this Range's magnitude in each dimension.\r\n//    */\r\n//   get magnitude():Pt { return this._mag.clone(); }\r\n\r\n\r\n//   /**\r\n//    * Go through the group and find its min and max values. Usually you don't need to call this function directly.\r\n//    */\r\n//   calc():this {\r\n//     if (!this._source) return;\r\n//     let dims = this._source[0].length;\r\n//     this._dims = dims;\r\n//     let max = new Pt( dims );\r\n//     let min = new Pt( dims );\r\n//     let mag = new Pt( dims );\r\n\r\n//     for (let i=0; i<dims; i++) {\r\n//       max[i] = Const.min;\r\n//       min[i] = Const.max;\r\n//       mag[i] = 0;\r\n\r\n//       let s = this._source.zipSlice( i );\r\n//       for (let k=0, len=s.length; k<len; k++) {\r\n//         max[i] = Math.max( max[i], s[k] );\r\n//         min[i] = Math.min( min[i], s[k] );\r\n//         mag[i] = max[i] - min[i];\r\n//       }\r\n//     }\r\n\r\n//     this._max = max;\r\n//     this._min = min;\r\n//     this._mag = mag;\r\n//     return this;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Map this Range to another range of values.\r\n//    * @param min target range's minimum value\r\n//    * @param max target range's maximum value\r\n//    * @param exclude Optional boolean array where `true` means excluding the conversion in that specific dimension.\r\n//    */\r\n//   mapTo( min:number, max:number, exclude?:boolean[] ):Group {\r\n//     let target = new Group();\r\n//     for (let i=0, len=this._source.length; i<len; i++) {\r\n//       let g = this._source[i];\r\n//       let n = new Pt( this._dims );\r\n//       for (let k=0; k<this._dims; k++) {\r\n//         n[k] = (exclude && exclude[k]) ? g[k] : Num.mapToRange( g[k], this._min[k], this._max[k], min, max ); \r\n//       }\r\n//       target.push( n ); \r\n//     }\r\n//     return target;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Add more Pts to this Range and recalculate its min and max values.\r\n//    * @param g a Group or an array of Pts to append to this Range\r\n//    * @param update Optional. Set the parameter to `false` if you want to append without immediately updating this Range's min and max values. Default is `true`.\r\n//    */\r\n//   append( g:GroupLike, update:boolean=true ):this {\r\n//     if (g[0].length !== this._dims) throw new Error(`Dimensions don't match. ${this._dims} dimensions in Range and ${g[0].length} provided in parameter. `);\r\n//     this._source = this._source.concat( g ) as Group;\r\n//     if (update) this.calc();\r\n//     return this;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Create a number of evenly spaced \"ticks\" that span this Range's min and max value.\r\n//    * @param count number of subdivision. For example, 10 subdivision will return 11 tick values, which include first(min) and last(max) values.\r\n//    */\r\n//   ticks( count:number ):Group {\r\n//     let g = new Group();\r\n//     for (let i=0; i<=count; i++) {\r\n//       let p = new Pt( this._dims );\r\n//       for (let k=0, len=this._max.length; k<len; k++) {\r\n//         p[k] = Num.lerp( this._min[k], this._max[k], i/count );\r\n//       }\r\n//       g.push( p );\r\n//     }\r\n//     return g;\r\n//   }\r\n\r\n}","class VectorStatic {\r\n    static add(vectA: Vector, vectB: Vector) {\r\n        return new Vector(\r\n            vectA.x + vectB.x,\r\n            vectA.y + vectB.y,\r\n            vectA.z + vectB.z\r\n        )\r\n    }\r\n}\r\n\r\nexport class Vector extends VectorStatic {\r\n    #x = 0\r\n    #y = 0\r\n    #z = 0\r\n\r\n    get x() {\r\n        return this.#x\r\n    }\r\n    set x(x: number) {\r\n        if (typeof x === 'number') this.#x = x\r\n    }\r\n    get y() {\r\n        return this.#y\r\n    }\r\n    set y(y: number) {\r\n        if (typeof y === 'number') this.#y = y\r\n    }\r\n    get z() {\r\n        return this.#z\r\n    }\r\n    set z(z: number) {\r\n        if (typeof z === 'number') this.#z = z\r\n    }\r\n\r\n    constructor(x?: number, y?: number, z?: number) {\r\n        super()\r\n        this.x = x || 0\r\n        this.y = y || 0\r\n        this.z = z || 0\r\n    }\r\n\r\n    set(x?: number, y?: number, z?: number): this {\r\n        this.x = typeof x === 'number' ? x : this.x\r\n        this.y = typeof y === 'number' ? y : this.y\r\n        this.z = typeof z === 'number' ? z : this.z\r\n        return this\r\n    }\r\n\r\n    copy(): Vector {\r\n        return new Vector(this.x, this.y, this.z)\r\n    }\r\n\r\n    add(x?: number | Vector, y?: number, z?: number): this {\r\n        if (x instanceof Vector) {\r\n            this.x += x.x || 0\r\n            this.y += x.y || 0\r\n            this.z += x.z || 0\r\n            return this\r\n        }\r\n        this.x += x || 0\r\n        this.y += y || 0\r\n        this.z += z || 0\r\n        return this\r\n    }\r\n\r\n    sub(x?: number | Vector, y?: number, z?: number): this {\r\n        if (x instanceof Vector) {\r\n            this.x -= x.x || 0\r\n            this.y -= x.y || 0\r\n            this.z -= x.z || 0\r\n            return this\r\n        }\r\n        this.x -= x || 0\r\n        this.y -= y || 0\r\n        this.z -= z || 0\r\n        return this\r\n    }\r\n\r\n    mult(n: number): this {\r\n        if (!(typeof n === 'number' && isFinite(n))) {\r\n            console.warn( 'n is undefined or not a finite number' )\r\n            return this\r\n        }\r\n        this.x *= n\r\n        this.y *= n\r\n        this.z *= n\r\n        return this\r\n    }\r\n\r\n    div(n: number): this {\r\n        if (!(typeof n === 'number' && isFinite(n))) {\r\n            console.warn( 'n is undefined or not a finite number' )\r\n            return this\r\n        }\r\n        if (n === 0) {\r\n            console.warn('n is 0');\r\n            return this;\r\n        }\r\n        this.x /= n\r\n        this.y /= n\r\n        this.z /= n\r\n        return this\r\n    }\r\n\r\n    dist(x: number | Vector, y: number, z: number): number {\r\n        if (x instanceof Vector) {\r\n            return Math.sqrt(\r\n                Math.pow(x.x - this.x, 2) +\r\n                Math.pow(x.y - this.y, 2) +\r\n                Math.pow(x.z - this.z, 2)\r\n            )\r\n        }\r\n        return Math.sqrt(\r\n            Math.pow(x - this.x, 2) +\r\n            Math.pow(y - this.y, 2) +\r\n            Math.pow(z - this.z, 2)\r\n        )\r\n    }\r\n\r\n    mag() {\r\n        return Math.sqrt(\r\n            Math.pow(this.x, 2) +\r\n            Math.pow(this.y, 2) +\r\n            Math.pow(this.z, 2)\r\n        )\r\n    }\r\n\r\n    magSq() {\r\n        \r\n    }\r\n}"],"sourceRoot":""}