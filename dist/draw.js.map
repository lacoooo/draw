{"version":3,"sources":["webpack://draw/webpack/universalModuleDefinition","webpack://draw/webpack/bootstrap","webpack://draw/./src/canvas.ts","webpack://draw/./src/index.ts","webpack://draw/./src/num.ts"],"names":[],"mappings":"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","file":"draw.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"draw\"] = factory();\n\telse\n\t\troot[\"draw\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","import { Isetup } from './types'\r\n\r\nexport class Canvas {\r\n\r\n    protected _canvas: HTMLCanvasElement\r\n    protected _ctx: CanvasRenderingContext2D\r\n    public frame = 0\r\n    public width = 1000\r\n    public height = 1000\r\n\r\n    constructor(params?: Isetup) {\r\n        const { canvasId } = params || {}\r\n        if (canvasId) {\r\n            const canvas = document.getElementById(canvasId) as HTMLCanvasElement\r\n            if (canvas !== null) this._canvas = canvas\r\n            else this._canvas = this._createElement(\"canvas\") as HTMLCanvasElement\r\n        }\r\n        else {\r\n            this._canvas = this._createElement(\"canvas\") as HTMLCanvasElement\r\n            document.body.appendChild(this._canvas)\r\n        }\r\n        this._ctx = this._canvas.getContext('2d') as CanvasRenderingContext2D\r\n\r\n        \r\n        const {width, height} = params || {}\r\n        this._canvas.width = width || this.width\r\n        this._canvas.height = height || this.height\r\n        this.width = this._canvas.width\r\n        this.height = this._canvas.height\r\n    }\r\n\r\n    /**\r\n    * Helper function to create a DOM element\r\n    * @param elem element tag name\r\n    */\r\n    protected _createElement(elem = \"div\"): HTMLElement {\r\n        const d = document.createElement(elem)\r\n        return d\r\n    }\r\n\r\n    public setup(cb: (ctx: CanvasRenderingContext2D) => void) {\r\n        if (cb) {\r\n            cb(this._ctx)\r\n        }\r\n    }\r\n\r\n    public loop(cb: (ctx: CanvasRenderingContext2D) => void) {\r\n        this.frame ++\r\n        if (cb) cb(this._ctx)\r\n        requestAnimationFrame(this.loop.bind(this, cb))\r\n    }\r\n\r\n    public strokeWeight(width: number) {\r\n        this._ctx.lineWidth = width\r\n    }\r\n\r\n    private stroke() {\r\n        this._ctx.stroke()\r\n    }\r\n\r\n    public beginPath() {\r\n        this._ctx.beginPath()\r\n    }\r\n\r\n    public closePath() {\r\n        this._ctx.closePath()\r\n    }\r\n\r\n    public line(x1: number, y1: number, x2: number, y2: number) {\r\n        this.beginPath()\r\n        this._ctx.moveTo(x1, y1)\r\n        this._ctx.lineTo(x2, y2)\r\n        this.closePath()\r\n        this.stroke()\r\n    }\r\n}","import { Canvas } from './canvas'\r\nimport { Num } from './num'\r\nimport { Isetup } from './types'\r\n\r\nwindow.Draw = ( params:Isetup ) => {\r\n    return new Canvas(params)\r\n}\r\n\r\nwindow.Num = Num","/*! Source code licensed under Apache License 2.0. Copyright Â© 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\r\n\r\n// import { Const } from \"./Util\";\r\n// import { Curve } from \"./Op\";\r\n// import { Pt, Group } from \"./Pt\";\r\n// import { Vec, Mat } from \"./LinearAlgebra\";\r\n// import {PtLike, GroupLike} from \"./Types\";\r\n/**\r\n * Num class provides static helper functions for basic numeric operations.\r\n */\r\nexport const Num = {\r\n\r\n  /**\r\n   * Check if two numbers are equal or almost equal within a threshold.\r\n   * @param a number a\r\n   * @param b number b\r\n   * @param threshold threshold value that specifies the minimum difference within which the two numbers are considered equal\r\n   */\r\n  equals( a:number, b:number, threshold=0.00001 ):boolean {\r\n    return Math.abs( a-b ) < threshold;\r\n  },\r\n\r\n\r\n  /**\r\n   * Calculate linear interpolation between 2 values.\r\n   * @param a start value\r\n   * @param b end value\r\n   * @param t an interpolation value, usually between 0 to 1\r\n   */\r\n  lerp( a:number, b:number, t:number ):number {\r\n    return (1 - t) * a + t * b;\r\n  },\r\n\r\n\r\n  /**\r\n   * Clamp values between min and max.\r\n   * @param val value to clamp\r\n   * @param min min value\r\n   * @param max max value\r\n   */\r\n  clamp( val:number, min:number, max:number ):number {\r\n    return Math.max(min, Math.min(max, val));\r\n  },\r\n\r\n\r\n//   /**\r\n//    * Different from [`Num.clamp`](#link) in that the value out-of-bound will be \"looped back\" to the other end.\r\n//    * @param val value to bound\r\n//    * @param min min value\r\n//    * @param max max value\r\n//    * @example `boundValue(361, 0, 360)` will return 1\r\n//    */\r\n//   boundValue( val:number, min:number, max:number ):number {\r\n//     let len = Math.abs(max - min);\r\n//     let a = val % len;\r\n\r\n//     if (a > max) a -= len;\r\n//     else if (a < min) a += len;\r\n\r\n//     return a;\r\n//   },\r\n\r\n\r\n  /**\r\n   * Check if a value is within two other values\r\n   * @param p value to check\r\n   * @param a first bounding value\r\n   * @param b second bounding value\r\n   */\r\n  within( p:number, a:number, b:number ):boolean {\r\n    return p >= Math.min(a, b) && p <= Math.max(a, b);\r\n  },\r\n\r\n\r\n  /**\r\n   * Get a random number within a range.\r\n   * @param a range value 1\r\n   * @param b range value 2\r\n   */\r\n  randomRange( a:number, b:number = 0 ):number {\r\n    const r = (a > b) ? (a - b) : (b - a);\r\n    return a + Math.random() * r;\r\n  },\r\n\r\n\r\n//   /**\r\n//    * Normalize a value within a range.\r\n//    * @param n the value to normalize\r\n//    * @param a range value 1\r\n//    * @param b range value 1\r\n//    */\r\n//   normalizeValue(n:number, a:number, b:number):number {\r\n//     const min = Math.min(a, b);\r\n//     const max = Math.max(a, b);\r\n//     return (n - min) / (max - min);\r\n//   },\r\n\r\n\r\n//   /**\r\n//    * Sum a group of numeric arrays.\r\n//    * @param pts an array of numeric arrays\r\n//    * @returns a Pt of the dimensional sums\r\n//    */\r\n//   sum(pts: GroupLike|number[][]): Pt {\r\n//     let c = new Pt( pts[0] );\r\n//     for (let i = 1, len = pts.length; i < len; i++) {\r\n//       Vec.add(c, pts[i]);\r\n//     }\r\n//     return c;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Average a group of numeric arrays\r\n//    * @param pts an array of numeric arrays\r\n//    * @returns a Pt of averages\r\n//    */\r\n//   static average(pts: GroupLike|number[][]): Pt {\r\n//     return Num.sum(pts).divide(pts.length);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Given a value between 0 to 1, returns a value that cycles between 0 -> 1 -> 0 using the provided shaping method.\r\n//    * @param t a value between 0 to 1\r\n//    * @param method a shaping method. Default to [`Shaping.sineInOut`](#link).\r\n//    * @return a value between 0 to 1\r\n//    */\r\n//   static cycle( t:number, method:(t:number) => number=Shaping.sineInOut ):number {\r\n//     return method( t > 0.5 ? 2-t*2 : t*2 );\r\n//   }\r\n\r\n\r\n//   /**  \r\n//    * Map a value from one range to another.\r\n//    * @param n a value in the first range\r\n//    * @param currMin lower bound of the first range\r\n//    * @param currMax upper bound of the first range\r\n//    * @param targetMin lower bound of the second range\r\n//    * @param targetMax upper bound of the second range\r\n//    * @returns a remapped value in the second range\r\n//    */\r\n//   static mapToRange(n:number, currA:number, currB:number, targetA:number, targetB:number) {\r\n//     if (currA == currB) throw new Error(\"[currMin, currMax] must define a range that is not zero\");\r\n//     let min = Math.min(targetA, targetB);\r\n//     let max = Math.max(targetA, targetB);\r\n//     return Num.normalizeValue(n, currA, currB) * (max - min) + min;\r\n//   }\r\n}\r\n\r\n\r\n\r\n// /**\r\n//  * Geom class provides static helper functions for basic geometric operations.\r\n//  */\r\nexport class Geom {\r\n\r\n//   /**\r\n//    * Bound an angle between 0 to 360 degrees.\r\n//    * @param angle angle value\r\n//    */\r\n//   static boundAngle( angle:number ):number {\r\n//     return Num.boundValue(angle, 0, 360);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Bound a radian between 0 to two PI.\r\n//    * @param radian radian value\r\n//    */\r\n//   static boundRadian( radian:number ):number {\r\n//     return Num.boundValue(radian, 0, Const.two_pi);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Convert an angle in degree to radian.\r\n//    * @param angle angle value\r\n//    */\r\n//   static toRadian( angle:number ):number {\r\n//     return angle * Const.deg_to_rad;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Convert an angle in radian to degree.\r\n//    * @param radian radian value\r\n//    */\r\n//   static toDegree( radian:number ):number {\r\n//     return radian * Const.rad_to_deg;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Get a bounding box for a set of Pts.\r\n//    * @param pts a Group or an array of Pts\r\n//    * @return a Group of two Pts, representing the top-left and bottom-right corners\r\n//    */\r\n//   static boundingBox( pts:GroupLike ): Group {\r\n//     let minPt = pts.reduce((a: Pt, p: Pt) => a.$min(p));\r\n//     let maxPt = pts.reduce((a: Pt, p: Pt) => a.$max(p));\r\n//     return new Group(minPt, maxPt);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Get a centroid (the average middle point) for a set of Pts.\r\n//    * @param pts a Group or an array of Pts\r\n//    * @return a centroid Pt \r\n//    */\r\n//   static centroid( pts:GroupLike|number[][] ):Pt {\r\n//     return Num.average(pts);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Given an anchor Pt, rebase all Pts in this group either to or from this anchor base.\r\n//    * @param pts a Group or array of Pt\r\n//    * @param ptOrIndex an index for the Pt array, or an external Pt\r\n//    * @param direction a string either \"to\" (subtract all Pt with this anchor base), or \"from\" (add all Pt from this anchor base)\r\n//    */\r\n//   static anchor( pts:GroupLike, ptOrIndex:PtLike|number=0, direction:(\"to\"|\"from\")=\"to\") {\r\n//     let method = (direction == \"to\") ? \"subtract\" : \"add\";\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       if (typeof ptOrIndex == \"number\") {\r\n//         if (ptOrIndex !== i) pts[i][method](pts[ptOrIndex]);\r\n//       } else {\r\n//         pts[i][method](ptOrIndex);\r\n//       }\r\n//     }\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Get an interpolated (or extrapolated) value between two Pts. For linear interpolation between 2 scalar values, use [`Num.lerp`](#link).\r\n//    * @param a first Pt\r\n//    * @param b second Pt\r\n//    * @param t a value between 0 to 1 to interpolate, or any other value to extrapolate\r\n//    * @returns interpolated point as a new Pt\r\n//    */\r\n//   static interpolate( a:Pt|number[], b:Pt|number[], t:number=0.5 ):Pt {\r\n//     let len = Math.min(a.length, b.length);\r\n//     let d = Pt.make(len);\r\n//     for (let i = 0; i < len; i++) {\r\n//       d[i] = a[i] * (1 - t) + b[i] * t;\r\n//     }\r\n//     return d;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Find two Pts that are perpendicular to this Pt (2D only).\r\n//    * @param axis a string such as \"xy\" (use Const.xy) or an array to specify index for two dimensions\r\n//    * @returns an array of two Pt that are perpendicular to this Pt\r\n//    */\r\n//   static perpendicular( pt:PtLike, axis:string|number[]=Const.xy ):Group {\r\n//     let y = axis[1];\r\n//     let x = axis[0];\r\n\r\n//     let p = new Pt(pt);\r\n//     let pa = new Pt(p);\r\n//     pa[x] = -p[y];\r\n//     pa[y] = p[x];\r\n//     let pb = new Pt(p);\r\n//     pb[x] = p[y];\r\n//     pb[y] = -p[x];\r\n\r\n//     return new Group(pa, pb);\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Check if two Pts are perpendicular to each other (2D only).\r\n//    */\r\n//   static isPerpendicular( p1:PtLike, p2:PtLike ):boolean {\r\n//     return new Pt(p1).dot(p2) === 0;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Check if a Pt is within the rectangular boundary defined by two Pts.\r\n//    * @param pt the Pt to check\r\n//    * @param boundPt1 boundary Pt 1\r\n//    * @param boundPt2 boundary Pt 2\r\n//    */\r\n//   static withinBound( pt:PtLike|number[], boundPt1:PtLike|number[], boundPt2:PtLike|number[] ):boolean {\r\n//     for (let i = 0, len = Math.min(pt.length, boundPt1.length, boundPt2.length); i < len; i++) {\r\n//       if (!Num.within(pt[i], boundPt1[i], boundPt2[i])) return false;\r\n//     }\r\n//     return true;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Sort the Pts so that their edges will form a non-overlapping polygon. ([Reference](https://stackoverflow.com/questions/6989100/sort-points-in-clockwise-order))\r\n//    * @param pts an array of Pts\r\n//    */\r\n//   static sortEdges( pts:GroupLike ):GroupLike {\r\n\r\n//     let bounds = Geom.boundingBox( pts );\r\n//     let center = bounds[1].add(bounds[0]).divide(2);\r\n    \r\n//     let fn = ( a:Pt, b:Pt ):number => {\r\n//       if (a.length < 2 || b.length < 2) throw new Error( \"Pt dimension cannot be less than 2\");\r\n\r\n//       let da = a.$subtract( center );\r\n//       let db = b.$subtract( center );\r\n      \r\n//       if (da[0] >= 0 && db[0] < 0) return 1;\r\n//       if (da[0] < 0 && db[0] >= 0) return -1;\r\n//       if (da[0] == 0 && db[0] == 0) {\r\n//           if (da[1] >= 0 || db[1] >= 0)\r\n//               return (da[1] > db[1]) ? 1 : -1;\r\n//           return (db[1] > da[1]) ? 1 : -1;\r\n//       }\r\n\r\n//       // compute the cross product of vectors (center -> a) x (center -> b)\r\n//       let det = da.$cross2D( db );\r\n//       if (det < 0) return 1;\r\n//       if (det > 0) return -1;\r\n      \r\n//       // points a and b are on the same line from the center\r\n//       // check which point is closer to the center\r\n//       return (da[0]*da[0] + da[1]*da[1] > db[0]*db[0] + db[1]*db[1]) ? 1 : -1;\r\n//     };\r\n\r\n//     return pts.sort( fn );\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Scale a Pt or a Group of Pts. You may also use [`Pt.scale`](#link) instance method.\r\n//    * @param ps a Pt or a Group of Pts\r\n//    * @param scale scale value\r\n//    * @param anchor optional anchor point to scale from\r\n//    */\r\n//   static scale( ps:Pt|GroupLike, scale:number|number[]|PtLike, anchor?:PtLike ):Geom {\r\n//     let pts = (!Array.isArray(ps)) ? [ps] : ps;\r\n//     let scs = (typeof scale == \"number\") ? Pt.make(pts[0].length, scale) : scale;\r\n//     if (!anchor) anchor = Pt.make(pts[0].length, 0);\r\n\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       let p = pts[i];\r\n//       for (let k = 0, lenP = p.length; k < lenP; k++) {\r\n//         p[k] = (anchor && anchor[k]) ? anchor[k] + (p[k] - anchor[k]) * scs[k] : p[k] * scs[k];\r\n//       }\r\n//     }\r\n\r\n//     return Geom;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Rotate a Pt or a Group of Pts in 2D space. You may also use [`Pt.rotate2D`](#link) instance method.\r\n//    * @param ps a Pt or a Group of Pts\r\n//    * @param angle rotate angle\r\n//    * @param anchor optional anchor point to rotate from\r\n//    * @param axis optional axis such as \"xy\" (use Const.xy) to define a 2D plane, or a number array to specify indices\r\n//    */\r\n//   static rotate2D( ps:Pt|GroupLike, angle:number, anchor?:PtLike, axis?:string|number[] ):Geom {\r\n//     let pts = (!Array.isArray(ps)) ? [ps] : ps;\r\n//     let fn = (anchor) ? Mat.rotateAt2DMatrix : Mat.rotate2DMatrix;\r\n//     if (!anchor) anchor = Pt.make(pts[0].length, 0);\r\n//     let cos = Math.cos(angle);\r\n//     let sin = Math.sin(angle);\r\n\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       let p = (axis) ? pts[i].$take(axis) : pts[i];\r\n//       p.to(Mat.transform2D(p, fn(cos, sin, anchor)));\r\n//       if (axis) {\r\n//         for (let k = 0; k < axis.length; k++) {\r\n//           pts[i][axis[k]] = p[k];\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return Geom;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Shear a Pt or a Group of Pts in 2D space. You may also use [`Pt.shear2D`](#link) instance method.\r\n//    * @param ps a Pt or a Group of Pts\r\n//    * @param scale shearing value which can be a number or an array of 2 numbers\r\n//    * @param anchor optional anchor point to shear from\r\n//    * @param axis optional axis such as \"xy\" (use Const.xy) to define a 2D plane, or a number array to specify indices\r\n//    */\r\n//   static shear2D( ps:Pt|GroupLike, scale:number|number[]|PtLike, anchor?:PtLike, axis?:string|number[] ):Geom {\r\n//     let pts = (!Array.isArray(ps)) ? [ps] : ps;\r\n//     let s = (typeof scale == \"number\") ? [scale, scale] : scale;\r\n//     if (!anchor) anchor = Pt.make(pts[0].length, 0);\r\n//     let fn = (anchor) ? Mat.shearAt2DMatrix : Mat.shear2DMatrix;\r\n//     let tanx = Math.tan(s[0]);\r\n//     let tany = Math.tan(s[1]);\r\n\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       let p = (axis) ? pts[i].$take(axis) : pts[i];\r\n//       p.to(Mat.transform2D(p, fn(tanx, tany, anchor)));\r\n//       if (axis) {\r\n//         for (let k = 0; k < axis.length; k++) {\r\n//           pts[i][axis[k]] = p[k];\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return Geom;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Reflect a Pt or a Group of Pts along a 2D line. You may also use [`Pt.reflect2D`](#link) instance method.\r\n//    * @param ps a Pt or a Group of Pts\r\n//    * @param line a Group of 2 Pts that defines a line for reflection\r\n//    * @param axis optional axis such as \"xy\" (use Const.xy) to define a 2D plane, or a number array to specify indices\r\n//    */\r\n//   static reflect2D( ps:Pt|GroupLike, line:GroupLike, axis?:string|number[] ):Geom {\r\n//     let pts = (!Array.isArray(ps)) ? [ps] : ps;\r\n//     let mat = Mat.reflectAt2DMatrix(line[0], line[1]);\r\n\r\n//     for (let i = 0, len = pts.length; i < len; i++) {\r\n//       let p = (axis) ? pts[i].$take(axis) : pts[i];\r\n//       p.to(Mat.transform2D(p, mat));\r\n//       if (axis) {\r\n//         for (let k = 0; k < axis.length; k++) {\r\n//           pts[i][axis[k]] = p[k];\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return Geom;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Generate a cosine lookup table.\r\n//    * @returns an object with a cosine tables (array of 360 values) and a function to get cosine given a radian input. \r\n//    */\r\n//   static cosTable() {\r\n//     let cos = new Float64Array(360);\r\n\r\n//     for (let i = 0; i < 360; i++) cos[i] = Math.cos(i * Math.PI / 180);\r\n//     let find = (rad:number) => cos[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\r\n\r\n//     return { table: cos, cos: find };\r\n//   }\r\n\r\n//   /**\r\n//    * Generate a sine lookup table.\r\n//    * @returns an object with a sine tables (array of 360 values) and a function to get sine value given a radian input. \r\n//    */\r\n//   static sinTable() {\r\n//     let sin = new Float64Array(360);\r\n\r\n//     for (let i = 0; i < 360; i++) sin[i] = Math.sin(i * Math.PI / 180);\r\n//     let find = (rad:number) => sin[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\r\n\r\n//     return { table: sin, sin: find };\r\n//   }\r\n// }\r\n\r\n\r\n\r\n// /**\r\n//  * Shaping provides shaping functions to interpolate a value. These are useful for easing and transitions.\r\n//  */\r\n// export class Shaping {\r\n\r\n//   /**\r\n//    * Linear mapping.\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static linear(t:number, c:number = 1):number {\r\n//     return c * t;\r\n//   }\r\n\r\n//   /** \r\n//    * Quadratic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//   */\r\n//   static quadraticIn(t:number, c:number = 1):number {\r\n//     return c * t * t;\r\n//   }\r\n\r\n//   /** \r\n//    * Quadratic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//   */\r\n//   static quadraticOut(t:number, c:number = 1):number {\r\n//     return -c * t * (t - 2);\r\n//   }\r\n\r\n//   /** \r\n//    * Quadratic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static quadraticInOut(t:number, c:number = 1):number {\r\n//     let dt = t * 2;\r\n//     return (t < 0.5) ? c / 2 * t * t * 4 : -c / 2 * ((dt - 1) * (dt - 3) - 1);\r\n//   }\r\n\r\n//   /** \r\n//    * Cubic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static cubicIn(t:number, c:number = 1):number {\r\n//     return c * t * t * t;\r\n//   }\r\n\r\n//   /** \r\n//    * Cubic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static cubicOut(t:number, c:number = 1):number {\r\n//     let dt = t - 1;\r\n//     return c * (dt * dt * dt + 1);\r\n//   }\r\n\r\n//   /** \r\n//    * Cubic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static cubicInOut(t:number, c:number = 1):number {\r\n//     let dt = t * 2;\r\n//     return (t < 0.5) ? c / 2 * dt * dt * dt : c / 2 * ((dt - 2) * (dt - 2) * (dt - 2) + 2);\r\n//   }\r\n\r\n//   /** \r\n//    * Exponential ease in, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p a value between 0 to 1 to control the curve. Default is 0.25.\r\n//    */\r\n//   static exponentialIn(t:number, c:number = 1, p:number = 0.25):number {\r\n//     return c * Math.pow(t, 1 / p);\r\n//   }\r\n\r\n//   /** \r\n//    * Exponential ease out, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p a value between 0 to 1 to control the curve. Default is 0.25.\r\n//    */\r\n//   static exponentialOut(t:number, c:number = 1, p:number = 0.25):number {\r\n//     return c * Math.pow(t, p);\r\n//   }\r\n\r\n//   /** \r\n//    * Sinuous in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static sineIn(t:number, c:number = 1):number {\r\n//     return -c * Math.cos(t * Const.half_pi) + c;\r\n//   }\r\n\r\n//   /** \r\n//    * Sinuous out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static sineOut(t:number, c:number = 1):number {\r\n//     return c * Math.sin(t * Const.half_pi);\r\n//   }\r\n\r\n//   /** \r\n//    * Sinuous in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static sineInOut(t:number, c:number = 1):number {\r\n//     return -c / 2 * (Math.cos(Math.PI * t) - 1);\r\n//   }\r\n\r\n//   /** \r\n//    * A faster way to approximate cosine ease in-out using Blinn-Wyvill Approximation. Adapated from Golan Levin's [polynomial shaping](http://www.flong.com/texts/code/shapers_poly/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static cosineApprox(t:number, c:number = 1) {\r\n//     let t2 = t * t;\r\n//     let t4 = t2 * t2;\r\n//     let t6 = t4 * t2;\r\n//     return c * (4 * t6 / 9 - 17 * t4 / 9 + 22 * t2 / 9);\r\n//   }\r\n\r\n//   /** \r\n//    * Circular in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static circularIn(t:number, c:number = 1):number {\r\n//     return -c * (Math.sqrt(1 - t * t) - 1);\r\n//   }\r\n\r\n//   /** \r\n//    * Circular out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static circularOut(t:number, c:number = 1):number {\r\n//     let dt = t - 1;\r\n//     return c * Math.sqrt(1 - dt * dt);\r\n//   }\r\n\r\n//   /** \r\n//    * Circular in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static circularInOut(t:number, c:number = 1):number {\r\n//     let dt = t * 2;\r\n//     return (t < 0.5) ? -c / 2 * (Math.sqrt(1 - dt * dt) - 1) : c / 2 * (Math.sqrt(1 - (dt - 2) * (dt - 2)) + 1);\r\n//   }\r\n\r\n//   /** \r\n//    * Elastic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.\r\n//    */\r\n//   static elasticIn(t:number, c:number = 1, p:number = 0.7):number {\r\n//     let dt = t - 1;\r\n//     let s = (p / Const.two_pi) * 1.5707963267948966;\r\n//     return c * (-Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p));\r\n//   }\r\n\r\n//   /** \r\n//    * Elastic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.\r\n//    */\r\n//   static elasticOut(t:number, c:number = 1, p:number = 0.7):number {\r\n//     let s = (p / Const.two_pi) * 1.5707963267948966;\r\n//     return c * (Math.pow(2, -10 * t) * Math.sin((t - s) * Const.two_pi / p)) + c;\r\n//   }\r\n\r\n//   /** \r\n//    * Elastic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.6.\r\n//    */\r\n//   static elasticInOut(t:number, c:number = 1, p:number = 0.6):number {\r\n//     let dt = t * 2;\r\n//     let s = (p / Const.two_pi) * 1.5707963267948966;\r\n//     if (t < 0.5) {\r\n//       dt -= 1;\r\n//       return c * (-0.5 * (Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p)));\r\n//     } else {\r\n//       dt -= 1;\r\n//       return c * (0.5 * (Math.pow(2, -10 * dt) * Math.sin((dt - s) * Const.two_pi / p))) + c;\r\n//     }\r\n//   }\r\n\r\n//   /** \r\n//    * Bounce in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static bounceIn(t:number, c:number = 1):number {\r\n//     return c - Shaping.bounceOut((1 - t), c);\r\n//   }\r\n\r\n//   /** \r\n//    * Bounce out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static bounceOut(t:number, c:number = 1) {\r\n//     if (t < (1 / 2.75)) {\r\n//       return c * (7.5625 * t * t);\r\n//     } else if (t < (2 / 2.75)) {\r\n//       t -= 1.5 / 2.75;\r\n//       return c * (7.5625 * t * t + 0.75);\r\n//     } else if (t < (2.5 / 2.75)) {\r\n//       t -= 2.25 / 2.75;\r\n//       return c * (7.5625 * t * t + 0.9375);\r\n//     } else {\r\n//       t -= 2.625 / 2.75;\r\n//       return c * (7.5625 * t * t + 0.984375);\r\n//     }\r\n//   }\r\n\r\n//   /** \r\n//    * Bounce in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    */\r\n//   static bounceInOut(t:number, c:number = 1):number {\r\n//     return (t < 0.5) ? Shaping.bounceIn(t * 2, c) / 2 : Shaping.bounceOut(t * 2 - 1, c) / 2 + c / 2;\r\n//   }\r\n\r\n//   /** \r\n//    * Sigmoid curve changes its shape adapted from the input value, but always returns a value between 0 to 1.\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p the larger the value, the \"steeper\" the curve will be. Default is 10.\r\n//    */\r\n//   static sigmoid(t:number, c:number = 1, p:number = 10):number {\r\n//     let d = p * (t - 0.5);\r\n//     return c / (1 + Math.exp(-d));\r\n//   }\r\n\r\n//   /** \r\n//    * Logistic sigmoid, adapted from Golan Levin's [shaping function](http://www.flong.com/texts/code/shapers_exp/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.7.\r\n//    */\r\n//   static logSigmoid(t:number, c:number = 1, p:number = 0.7):number {\r\n//     p = Math.max(Const.epsilon, Math.min(1 - Const.epsilon, p));\r\n//     p = 1 / (1 - p);\r\n\r\n//     let A = 1 / (1 + Math.exp(((t - 0.5) * p * -2)));\r\n//     let B = 1 / (1 + Math.exp(p));\r\n//     let C = 1 / (1 + Math.exp(-p));\r\n//     return c * (A - B) / (C - B);\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Exponential seat curve, adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.5.\r\n//    */\r\n//   static seat(t:number, c:number = 1, p:number = 0.5):number {\r\n//     if ((t < 0.5)) {\r\n//       return c * (Math.pow(2 * t, 1 - p)) / 2;\r\n//     } else {\r\n//       return c * (1 - (Math.pow(2 * (1 - t), 1 - p)) / 2);\r\n//     }\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Quadratic bezier curve, adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p1 a Pt object specifying the first control Pt, or a value specifying the control Pt's x position (its y position will default to 0.5). Default is `Pt(0.95, 0.95)\r\n//    */\r\n//   static quadraticBezier(t:number, c:number = 1, p:number|PtLike=[0.05, 0.95] ):number {\r\n//     let a:number = (typeof p != \"number\") ? p[0] : p;\r\n//     let b:number = (typeof p != \"number\") ? p[1] : 0.5;\r\n//     let om2a = 1 - 2 * a;\r\n//     if (om2a === 0) {\r\n//       om2a = Const.epsilon;\r\n//     }\r\n//     let d = (Math.sqrt(a * a + om2a * t) - a) / om2a;\r\n//     return c * ((1 - 2 * b) * (d * d) + (2 * b) * d);\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Cubic bezier curve. This reuses the bezier functions in Curve class.\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p1` a Pt object specifying the first control Pt. Default is `Pt(0.1, 0.7).\r\n//    * @param p2` a Pt object specifying the second control Pt. Default is `Pt(0.9, 0.2).\r\n//    */\r\n//   static cubicBezier(t:number, c:number = 1, p1:PtLike=[0.1, 0.7], p2:PtLike=[0.9, 0.2] ):number {\r\n//     let curve = new Group( new Pt(0, 0), new Pt(p1), new Pt(p2), new Pt(1, 1) );\r\n//     return c * Curve.bezierStep(new Pt(t*t*t, t*t, t, 1), Curve.controlPoints(curve)).y;\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Give a Pt, draw a quadratic curve that will pass through that Pt as closely as possible. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_poly/).\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p1` a Pt object specifying the Pt to pass through. Default is `Pt(0.2, 0.35)\r\n//    */\r\n//   static quadraticTarget(t:number, c:number = 1, p1:PtLike = [0.2, 0.35]):number {\r\n//     let a = Math.min(1 - Const.epsilon, Math.max( Const.epsilon, p1[0] ));\r\n//     let b = Math.min(1, Math.max( 0, p1[1] ));\r\n//     let A = (1 - b) / (1 - a) - (b / a);\r\n//     let B = (A * (a * a) - b) / a;\r\n//     let y = A * (t * t) - B * t;\r\n//     return c * Math.min(1, Math.max(0, y));\r\n//   }\r\n\r\n\r\n//   /** \r\n//    * Step function is a simple jump from 0 to 1 at a specific Pt in time.\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param p usually a value between 0 to 1, which specify the Pt to \"jump\". Default is 0.5 which is in the middle.\r\n//    */\r\n//   static cliff(t:number, c:number = 1, p:number = 0.5):number {\r\n//     return (t > p) ? c : 0;\r\n//   }\r\n\r\n//   /** \r\n//    * Convert any shaping functions into a series of steps.\r\n//    * @param fn the original shaping function\r\n//    * @param steps the number of steps\r\n//    * @param t a value between 0 to 1\r\n//    * @param c the value to shape, default is 1\r\n//    * @param args optional paramters to pass to original function\r\n//    */\r\n//   static step(fn: Function, steps:number, t:number, c:number, ...args:any[]) {\r\n//     let s = 1 / steps;\r\n//     let tt = Math.floor(t / s) * s;\r\n//     return fn(tt, c, ...args);\r\n//   }\r\n\r\n// }\r\n\r\n\r\n// /**\r\n//  * Range object keeps track of a Group of n-dimensional Pts to provide its minimum, maximum, and magnitude in each dimension. \r\n//  * It also provides convenient functions such as mapping the Group to another range. This class may be useful for visualizing data in charts.\r\n//  */\r\n// export class Range {\r\n\r\n//   protected _source:Group;\r\n//   protected _max:Pt;\r\n//   protected _min:Pt;\r\n//   protected _mag:Pt;\r\n//   protected _dims:number = 0;\r\n\r\n\r\n//   /**\r\n//    * Construct a Range instance for a Group of Pts.\r\n//    * @param g a Group or an array of Pts\r\n//    */\r\n//   constructor( g:GroupLike ) {\r\n//     this._source = Group.fromPtArray( g );\r\n//     this.calc();\r\n//   }\r\n\r\n//   /**\r\n//    * Get this Range's maximum values per dimension.\r\n//    */\r\n//   get max():Pt { return this._max.clone(); }\r\n  \r\n//   /**\r\n//    * Get this Range's minimum values per dimension.\r\n//    */\r\n//   get min():Pt { return this._min.clone(); }\r\n  \r\n//   /**\r\n//    * Get this Range's magnitude in each dimension.\r\n//    */\r\n//   get magnitude():Pt { return this._mag.clone(); }\r\n\r\n\r\n//   /**\r\n//    * Go through the group and find its min and max values. Usually you don't need to call this function directly.\r\n//    */\r\n//   calc():this {\r\n//     if (!this._source) return;\r\n//     let dims = this._source[0].length;\r\n//     this._dims = dims;\r\n//     let max = new Pt( dims );\r\n//     let min = new Pt( dims );\r\n//     let mag = new Pt( dims );\r\n\r\n//     for (let i=0; i<dims; i++) {\r\n//       max[i] = Const.min;\r\n//       min[i] = Const.max;\r\n//       mag[i] = 0;\r\n\r\n//       let s = this._source.zipSlice( i );\r\n//       for (let k=0, len=s.length; k<len; k++) {\r\n//         max[i] = Math.max( max[i], s[k] );\r\n//         min[i] = Math.min( min[i], s[k] );\r\n//         mag[i] = max[i] - min[i];\r\n//       }\r\n//     }\r\n\r\n//     this._max = max;\r\n//     this._min = min;\r\n//     this._mag = mag;\r\n//     return this;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Map this Range to another range of values.\r\n//    * @param min target range's minimum value\r\n//    * @param max target range's maximum value\r\n//    * @param exclude Optional boolean array where `true` means excluding the conversion in that specific dimension.\r\n//    */\r\n//   mapTo( min:number, max:number, exclude?:boolean[] ):Group {\r\n//     let target = new Group();\r\n//     for (let i=0, len=this._source.length; i<len; i++) {\r\n//       let g = this._source[i];\r\n//       let n = new Pt( this._dims );\r\n//       for (let k=0; k<this._dims; k++) {\r\n//         n[k] = (exclude && exclude[k]) ? g[k] : Num.mapToRange( g[k], this._min[k], this._max[k], min, max ); \r\n//       }\r\n//       target.push( n ); \r\n//     }\r\n//     return target;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Add more Pts to this Range and recalculate its min and max values.\r\n//    * @param g a Group or an array of Pts to append to this Range\r\n//    * @param update Optional. Set the parameter to `false` if you want to append without immediately updating this Range's min and max values. Default is `true`.\r\n//    */\r\n//   append( g:GroupLike, update:boolean=true ):this {\r\n//     if (g[0].length !== this._dims) throw new Error(`Dimensions don't match. ${this._dims} dimensions in Range and ${g[0].length} provided in parameter. `);\r\n//     this._source = this._source.concat( g ) as Group;\r\n//     if (update) this.calc();\r\n//     return this;\r\n//   }\r\n\r\n\r\n//   /**\r\n//    * Create a number of evenly spaced \"ticks\" that span this Range's min and max value.\r\n//    * @param count number of subdivision. For example, 10 subdivision will return 11 tick values, which include first(min) and last(max) values.\r\n//    */\r\n//   ticks( count:number ):Group {\r\n//     let g = new Group();\r\n//     for (let i=0; i<=count; i++) {\r\n//       let p = new Pt( this._dims );\r\n//       for (let k=0, len=this._max.length; k<len; k++) {\r\n//         p[k] = Num.lerp( this._min[k], this._max[k], i/count );\r\n//       }\r\n//       g.push( p );\r\n//     }\r\n//     return g;\r\n//   }\r\n\r\n}"],"sourceRoot":""}